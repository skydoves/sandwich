{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>\ud83e\udd6a  Sandwich is an adaptable and lightweight sealed API library designed for handling API responses and exceptions in Android for Retrofit, and Kotlin Multiplatform for Ktor, and Ktorfit.</p>"},{"location":"#why-sandwich","title":"Why Sandwich?","text":"<p>Sandwich was conceived to streamline the creation of standardized interfaces to model responses from Retrofit, Ktor, and whatever. This library empowers you to handle body data, errors, and exceptional cases more succinctly, utilizing functional operators within a multi-layer architecture. With Sandwich, the need to create wrapper classes like Resource or Result is eliminated, allowing you to concentrate on your core business logic. Sandwich boasts features such as global response handling, Mapper, Operator, and exceptional compatibility, including ApiResponse With Coroutines.</p>"},{"location":"#download","title":"Download","text":"<p>Sandwich has achieved an impressive milestone, being downloaded in over 300,000 Android projects worldwide! </p>"},{"location":"#gradle","title":"Gradle","text":"<p>Add the dependency below into your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:sandwich:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:sandwich:$version\")\n}\n</code></pre> <p>For Kotlin Multiplatform, add the dependency below to your module's <code>build.gradle.kts</code> file:</p> <pre><code>sourceSets {\n    val commonMain by getting {\n        dependencies {\n            implementation(\"com.github.skydoves:sandwich:$version\")\n        }\n    }\n}\n</code></pre>"},{"location":"#references","title":"References","text":"<p>You can delve deeper into the art of modeling Retrofit responses through the following resources:</p> <ul> <li>[YouTube]: Modeling Retrofit responses with sealed classes and coroutines with Jaewoong Eum</li> <li>Modeling Retrofit Responses With Sealed Classes and Coroutines</li> <li>Handling success data and error callback responses from a network for Android projects using Sandwich</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>You can also check out nice use cases of this library in the repositories below:</p> <ul> <li>Pokedex: \ud83d\udde1\ufe0f Android Pokedex using Hilt, Motion, Coroutines, Flow, Jetpack (Room, ViewModel, LiveData) based on MVVM architecture.</li> <li>ChatGPT Android: \ud83d\udcf2 ChatGPT Android demonstrates OpenAI's ChatGPT on Android with Stream Chat SDK for Compose.</li> <li>DisneyMotions: \ud83e\udd81 A Disney app using transformation motions based on MVVM (ViewModel, Coroutines, LiveData, Room, Repository, Koin) architecture.</li> <li>MarvelHeroes: \u2764\ufe0f A sample Marvel heroes application based on MVVM (ViewModel, Coroutines, LiveData, Room, Repository, Koin)  architecture.</li> <li>Neko: Free, open source, unofficial MangaDex reader for Android.</li> <li>TheMovies2: \ud83c\udfac A demo project using The Movie DB based on Kotlin MVVM architecture and material design &amp; animations.</li> </ul>"},{"location":"apiresponse/","title":"ApiResponse","text":"<p><code>ApiResponse</code> serves as an interface designed to create consistent responses from API or I/O calls, such as network, database, or whatever. It offers convenient extensions to manage your payloads, encompassing both body data and exceptional scenarios. <code>ApiResponse</code> encompasses three distinct types: Success, Failure.Error, and Failure.Exception.</p>"},{"location":"apiresponse/#apiresponsesuccess","title":"ApiResponse.Success","text":"<p>This represents a successful response from API or I/O tasks. You can create an instance of [ApiResponse.Success] by giving the generic type and data.   </p> <pre><code>val apiResponse = ApiResponse.Success(data = myData)\nval data = apiResponse.data\n</code></pre> <p>Depending on your model designs, you can also utilize <code>tag</code> property. The <code>tag</code> is an additional value that can be held to distinguish the origin of the [data] or to facilitate post-processing of successful data.</p> <pre><code>val apiResponse = ApiResponse.Success(data = myData, tag = myTag)\nval tag = apiResponse.tag\n</code></pre>"},{"location":"apiresponse/#apiresponsefailureexception","title":"ApiResponse.Failure.Exception","text":"<p>This signals a failed tasks captured by unexpected exceptions during API request creation or response processing on the client side, such as a network connection failure. You can obtain exception details from the <code>ApiResponse.Failure.Exception</code>.</p> <pre><code>val apiResponse = ApiResponse.Failure.Exception(exception = HttpTimeoutException())\nval exception = apiResponse.exception\nval message = apiResponse.message\n</code></pre>"},{"location":"apiresponse/#apiresponsefailureerror","title":"ApiResponse.Failure.Error","text":"<p>This denotes a failed API or I/O request, typically due to bad requests or internal server errors. You can additionally put an error payload that can contain detailed error information.</p> <pre><code>val apiResponse = ApiResponse.Failure.Error(payload = errorBody)\nval payload = apiResponse.payload\n</code></pre> <p>You can also define custom error responses that extend <code>ApiResponse.Failure.Error</code> or <code>ApiResponse.Failure.Exception</code>, as demonstrated in the example below:</p> <pre><code>data object LimitedRequest : ApiResponse.Failure.Error(\n  payload = \"your request is limited\",\n)\n\ndata object WrongArgument : ApiResponse.Failure.Error(\n  payload = \"wrong argument\",\n)\n\ndata object HttpException : ApiResponse.Failure.Exception(\n  throwable = RuntimeException(\"http exception\")\n)\n</code></pre> <p>The custom error response is very useful when you want to explicitly define and handle error responses, especially when working with map extensions.</p> <pre><code>val apiResponse = service.fetchMovieList()\napiResponse.onSuccess {\n    // ..\n}.flatMap {\n  // if the ApiResponse is Failure.Error and contains error body, then maps it to a custom error response.  \n  if (this is ApiResponse.Failure.Error) {\n    val errorBody = (payload as? Response)?.body?.string()\n    if (errorBody != null) {\n      val errorMessage: ErrorMessage = Json.decodeFromString(errorBody)\n      when (errorMessage.code) {\n        10000 -&gt; LimitedRequest\n        10001 -&gt; WrongArgument\n      }\n    }\n  }\n  this\n}\n</code></pre> <p>Then you can handle the errors based on your custom message in other layers:</p> <pre><code>val apiResponse = repository.fetchMovieList()\napiResponse.onError {\n  when (this) {\n    LimitedRequest -&gt; // update your UI\n    WrongArgument -&gt; // update your UI\n  }\n}\n</code></pre> <p>You might not want to use the <code>flatMap</code> extension for all API requests. If you aim to standardize custom error types across all API requests, you can explore the Global Failure Mapper.</p>"},{"location":"apiresponse/#creation-of-apiresponse","title":"Creation of ApiResponse","text":"<p>Sandwich provides convenient ways to create an <code>ApiResponse</code> using functions such as <code>ApiResponse.of</code> or <code>apiResponseOf</code>, as shown below:</p> <pre><code>val apiResponse = ApiResponse.of { service.request() }\nval apiResponse = apiResponseOf { service.request() }\n</code></pre> <p>If you need to run suspend functions inside the lambda, you can use <code>ApiResponse.suspendOf</code> or <code>suspendApiResponseOf</code> instead:</p> <pre><code>val apiResponse = ApiResponse.suspendOf { service.request() }\nval apiResponse = suspendApiResponseOf { service.request() }\n</code></pre> <p>Note</p> <p>If you intend to utilize the global operator or global ApiResponse mapper in Sandwich, you should create an <code>ApiResponse</code> using the <code>ApiResponse.of</code> or <code>ApiResponse.suspendOf</code> method to ensure the application of these global functions. If you're using <code>ApiResponseFailureSuspendMapper</code> or <code>ApiResponseSuspendOperator</code> (common with Ktor/Ktorfit), use <code>ApiResponse.suspendOf</code> to ensure suspend mappers and operators are properly awaited.</p>"},{"location":"apiresponse/#apiresponse-extensions","title":"ApiResponse Extensions","text":"<p>You can effectively handle <code>ApiResponse</code> using the following extensions:</p> <ul> <li>onSuccess: Executes when the <code>ApiResponse</code> is of type <code>ApiResponse.Success</code>. Within this scope, you can directly access the body data.</li> <li>onError: Executes when the <code>ApiResponse</code> is of type <code>ApiResponse.Failure.Error</code>. You can access <code>messageOrNull</code> and <code>payload</code> here.</li> <li>onException: Executes when the <code>ApiResponse</code> is of type <code>ApiResponse.Failure.Exception</code>. You can access <code>messageOrNull</code> and <code>exception</code> here.</li> <li>onFailure: Executes when the <code>ApiResponse</code> is either <code>ApiResponse.Failure.Error</code> or <code>ApiResponse.Failure.Exception</code>. You can access <code>messageOrNull</code> here.</li> </ul> <p>Each scope operates according to its corresponding <code>ApiResponse</code> type:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\nresponse.onSuccess {\n    // this scope will be executed if the request successful.\n    // handle the success case\n  }.onError {\n    // this scope will be executed when the request failed with errors.\n    // handle the error case\n  }.onException {\n   // this scope will be executed when the request failed with exceptions.\n   // handle the exception case\n  }\n</code></pre> <p>If you don't want to specify each failure case, you can simplify it by using the <code>onFailure</code> extension:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\nresponse.onSuccess {\n    // this scope will be executed if the request successful.\n    // handle the success case\n  }.onFailure {\n\n  }\n</code></pre>"},{"location":"apiresponse/#apiresponse-extensions-with-coroutines","title":"ApiResponse Extensions With Coroutines","text":"<p>With the <code>ApiResponse</code> type, you can leverage Coroutines extensions to handle responses seamlessly within coroutine scopes. These extensions provide a convenient way to process different response types. Here's how you can use them:</p> <ul> <li> <p>suspendOnSuccess: This extension runs if the <code>ApiResponse</code> is of type <code>ApiResponse.Success</code>. You can access the body data directly within this scope.</p> </li> <li> <p>suspendOnError: This extension is executed if the <code>ApiResponse</code> is of type <code>ApiResponse.Failure.Error</code>. You can access the error message and the error body in this scope.</p> </li> <li> <p>suspendOnException: If the <code>ApiResponse</code> is of type <code>ApiResponse.Failure.Exception</code>, this extension is triggered. You can access the exception message in this scope.</p> </li> <li> <p>suspendOnFailure: This extension is executed if the <code>ApiResponse</code> is either <code>ApiResponse.Failure.Error</code> or <code>ApiResponse.Failure.Exception</code>. You can access the error message in this scope.</p> </li> </ul> <p>Each extension scope operates based on the corresponding <code>ApiResponse</code> type. By utilizing these extensions, you can handle responses effectively within different coroutine contexts.</p> <pre><code>flow {\n  val response = disneyService.fetchDisneyPosterList()\n  response.suspendOnSuccess {\n    posterDao.insertPosterList(data) // insertPosterList(data) is a suspend function.\n    emit(data)\n  }.suspendOnError {\n    // handles error cases\n  }.suspendOnException {\n    // handles exceptional cases\n  }\n}.flowOn(Dispatchers.IO)\n</code></pre>"},{"location":"apiresponse/#flow","title":"Flow","text":"<p>Sandwich offers some useful extensions to transform your <code>ApiResponse</code> into a Flow by using the <code>toFlow</code> extension:</p> <pre><code>val flow = disneyService.fetchDisneyPosterList()\n  .onError {\n    // handles error cases when the API request gets an error response.\n  }.onException {\n    // handles exceptional cases when the API request gets an exception response.\n  }.toFlow() // returns a coroutines flow\n  .flowOn(Dispatchers.IO)\n</code></pre> <p>If you want to transform the original data and work with a <code>Flow</code> containing the transformed data, you can do so as shown in the examples below:</p> <pre><code>val response = pokedexClient.fetchPokemonList(page = page)\nresponse.toFlow { pokemons -&gt;\n  pokemons.forEach { pokemon -&gt; pokemon.page = page }\n  pokemonDao.insertPokemonList(pokemons)\n  pokemonDao.getAllPokemonList(page)\n}.flowOn(Dispatchers.IO)\n</code></pre>"},{"location":"apiresponse/#recovery","title":"Recovery","text":"<p>Sandwich provides recovery extensions to transform a failed <code>ApiResponse</code> back into a successful one with fallback data.</p>"},{"location":"apiresponse/#recover","title":"recover","text":"<p>Returns an <code>ApiResponse.Success</code> with the fallback value if the response is a failure, otherwise returns the original success:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .recover(emptyList()) // Returns empty list if the request fails\n\n// With a lambda for lazy evaluation\nval response = disneyService.fetchDisneyPosterList()\n  .recover { cachedPosters }\n</code></pre>"},{"location":"apiresponse/#recoverwith","title":"recoverWith","text":"<p>Recovers the failure by executing an alternative <code>ApiResponse</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .recoverWith { failure -&gt;\n    // Try an alternative data source on failure\n    localDatabase.fetchCachedPosters()\n  }\n</code></pre> <p>For coroutines, use <code>suspendRecover</code> and <code>suspendRecoverWith</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .suspendRecoverWith { failure -&gt;\n    backupService.fetchPosters() // suspend function\n  }\n</code></pre>"},{"location":"apiresponse/#validation","title":"Validation","text":"<p>Validation extensions allow you to validate success data and convert it to a failure if the validation fails.</p>"},{"location":"apiresponse/#validate","title":"validate","text":"<p>Validates the success data with a predicate. If the predicate returns false, the response is converted to <code>ApiResponse.Failure.Error</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .validate(\n    predicate = { it.isNotEmpty() },\n    errorMessage = { \"Poster list cannot be empty\" }\n  )\n</code></pre>"},{"location":"apiresponse/#requirenotnull","title":"requireNotNull","text":"<p>Requires a non-null value from the success data. If the selected value is null, the response is converted to <code>ApiResponse.Failure.Error</code>:</p> <pre><code>val response = userService.fetchUser()\n  .requireNotNull(\n    selector = { it.profileImage },\n    errorMessage = { \"Profile image is required\" }\n  )\n</code></pre> <p>For coroutines, use <code>suspendValidate</code> and <code>suspendRequireNotNull</code>:</p> <pre><code>val response = userService.fetchUser()\n  .suspendValidate { user -&gt;\n    userValidator.isValid(user) // suspend function\n  }\n</code></pre>"},{"location":"apiresponse/#filter","title":"Filter","text":"<p>Filter extensions allow you to filter items in list data within an <code>ApiResponse</code>.</p>"},{"location":"apiresponse/#filter_1","title":"filter","text":"<p>Filters the items in the success data list, keeping only items that match the predicate:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .filter { poster -&gt; poster.isActive }\n</code></pre>"},{"location":"apiresponse/#filternot","title":"filterNot","text":"<p>Filters the items in the success data list, excluding items that match the predicate:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .filterNot { poster -&gt; poster.isDeprecated }\n</code></pre> <p>For coroutines, use <code>suspendFilter</code> and <code>suspendFilterNot</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .suspendFilter { poster -&gt;\n    posterValidator.isValid(poster) // suspend function\n  }\n</code></pre>"},{"location":"apiresponse/#zip-combine","title":"Zip / Combine","text":"<p>Zip extensions allow you to combine multiple <code>ApiResponse</code> instances into a single response.</p>"},{"location":"apiresponse/#zip","title":"zip","text":"<p>Combines two <code>ApiResponse</code> instances. If both are successful, the transform function is applied. If either is a failure, the first failure is returned:</p> <pre><code>val usersResponse = userService.fetchUsers()\nval postersResponse = disneyService.fetchPosters()\n\nval combined = usersResponse.zip(postersResponse) { users, posters -&gt;\n  HomeData(users = users, posters = posters)\n}\n\n// Or combine into a Pair\nval paired = usersResponse.zip(postersResponse) // Returns ApiResponse&lt;Pair&lt;Users, Posters&gt;&gt;\n</code></pre>"},{"location":"apiresponse/#zip3","title":"zip3","text":"<p>Combines three <code>ApiResponse</code> instances:</p> <pre><code>val response1 = service.fetchUsers()\nval response2 = service.fetchPosters()\nval response3 = service.fetchSettings()\n\nval combined = response1.zip3(response2, response3) { users, posters, settings -&gt;\n  AppData(users = users, posters = posters, settings = settings)\n}\n</code></pre> <p>For coroutines, use <code>suspendZip</code> and <code>suspendZip3</code>:</p> <pre><code>val combined = response1.suspendZip(response2) { data1, data2 -&gt;\n  processData(data1, data2) // suspend function\n}\n</code></pre>"},{"location":"apiresponse/#peek-tap","title":"Peek / Tap","text":"<p>Peek extensions allow you to observe the <code>ApiResponse</code> without modifying it. This is useful for logging, analytics, or side effects.</p>"},{"location":"apiresponse/#peek","title":"peek","text":"<p>Performs an action on the <code>ApiResponse</code> regardless of its type:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .peek { response -&gt;\n    logger.log(\"Response received: $response\")\n  }\n</code></pre>"},{"location":"apiresponse/#peeksuccess","title":"peekSuccess","text":"<p>Performs an action only if the response is successful:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .peekSuccess { posters -&gt;\n    analytics.trackPostersLoaded(posters.size)\n  }\n</code></pre>"},{"location":"apiresponse/#peekfailure","title":"peekFailure","text":"<p>Performs an action only if the response is a failure (either error or exception):</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .peekFailure { failure -&gt;\n    logger.error(\"Request failed: ${failure.message()}\")\n  }\n</code></pre>"},{"location":"apiresponse/#peekerror","title":"peekError","text":"<p>Performs an action only if the response is <code>ApiResponse.Failure.Error</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .peekError { error -&gt;\n    errorTracker.trackApiError(error.statusCode)\n  }\n</code></pre>"},{"location":"apiresponse/#peekexception","title":"peekException","text":"<p>Performs an action only if the response is <code>ApiResponse.Failure.Exception</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .peekException { exception -&gt;\n    crashReporter.recordException(exception.throwable)\n  }\n</code></pre> <p>For coroutines, use <code>suspendPeek</code>, <code>suspendPeekSuccess</code>, <code>suspendPeekFailure</code>, <code>suspendPeekError</code>, and <code>suspendPeekException</code>:</p> <pre><code>val response = disneyService.fetchDisneyPosterList()\n  .suspendPeekSuccess { posters -&gt;\n    cache.savePosters(posters) // suspend function\n  }\n</code></pre>"},{"location":"empty-body/","title":"Empty Body (No Content 204)","text":"<p>Sandwich seamlessly handles responses with an empty body (204 No Content) without requiring any additional effort.</p> <p>You can simply set the <code>ApiResponse</code> type to <code>Unit</code>, as shown in the example below:</p> <pre><code>interface AuthService {\n    @Delete(\"/auth/user\")\n    suspend fun deleteToken(@Body userToken: UserToken): ApiResponse&lt;Unit&gt;\n}\n</code></pre>"},{"location":"global/","title":"Global Handling","text":"<p>Sandwich provides seamless ways for globally handling responses across all your network and I/O tasks when creating <code>ApiResponse</code> instances.</p>"},{"location":"global/#global-operator","title":"Global Operator","text":"<p>You can execute your Operators globally when creating <code>ApiResponse</code> instances by utilizing <code>SandwichInitializer.sandwichOperators</code>. For more information, check out the Global Operator.</p>"},{"location":"global/#global-errorexception-mapper","title":"Global Error/Exception Mapper","text":"<p>You can map all your failure type (ApiResponse.Failure.Error and ApiResponse.Failure.Exception) into your preferred custom error types. Sandwich provides two mapper interfaces:</p> <ul> <li><code>ApiResponseFailureMapper</code>: For non-suspend contexts (Retrofit).</li> <li><code>ApiResponseFailureSuspendMapper</code>: For suspend contexts (Ktor/Ktorfit) where error body parsing requires suspend functions. Suspend mappers are properly awaited and their mapped results are correctly returned to callers.</li> </ul> <p>For more information, check out the Global Failure Mapper.</p>"},{"location":"global/#define-network-code-ranges","title":"Define Network Code Ranges","text":"<p>If you're using <code>sandwich-retrofit</code>, <code>sandwich-ktor</code>, or <code>sandwich-ktorfit</code>, you can specify the code range that determines whether your network response should be treated as a success or failure. The default range is between <code>200</code> and <code>299</code>, but you can adjust the range depending on your situation.</p> <pre><code>SandwichInitializer.successCodeRange = 200..310\n</code></pre>"},{"location":"global/#global-coroutine-scope","title":"Global Coroutine Scope","text":"<p>Sandwich employs a dedicated global Coroutine scope when you need to perform Operate, Mapper, or creating deferred responses using Retrofit. The default Coroutine scope is supervised and utilizes the IO dispatcher, but if you want to manage or inject your own Coroutine scope, you can change the scope like the code below:</p> <pre><code>SandwichInitializer.sandwichScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)\n</code></pre>"},{"location":"ktor/","title":"Ktor Integration","text":"<p>Sandwich provides seamless extensions for <code>ApiResponse</code> when working with Ktor. If you're developing a Kotlin Multiplatform project, it's strongly advised to use Sandwich Ktor because Retrofit is limited to Android. You can access <code>ApiResponse</code> through the <code>_ApiResponse</code> extensions when working with the <code>HttpClient</code>.</p> <p>To utilize these Ktor supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:sandwich-ktor:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:sandwich-ktor:$version\")\n}\n</code></pre> <p>For Kotlin Multiplatform, add the dependency below to your module's <code>build.gradle.kts</code> file:</p> <pre><code>sourceSets {\n    val commonMain by getting {\n        dependencies {\n            implementation(\"com.github.skydoves:sandwich-ktor:$version\")\n        }\n    }\n}\n</code></pre>"},{"location":"ktor/#apiresponse-from-the-httpclient","title":"ApiResponse from the HttpClient","text":"<pre><code>val client = HttpClient { .. }\n\nval apiResponse = client.requestApiResponse&lt;PokemonResponse&gt;(REQUEST_URL) \nval apiResponse = client.getApiResponse&lt;PokemonResponse&gt;(REQUEST_URL) \nval apiResponse = client.postApiResponse&lt;PokemonResponse&gt;(REQUEST_URL) \nval apiResponse = client.deleteApiResponse&lt;PokemonResponse&gt;(REQUEST_URL) \nval apiResponse = client.patchApiResponse&lt;PokemonResponse&gt;(REQUEST_URL) \nval apiResponse = client.headApiResponse&lt;PokemonResponse&gt;(REQUEST_URL) \n</code></pre> <p>You can also utilize the <code>HttpRequestBuilder</code>:</p> <pre><code>val response = client.getApiResponse&lt;PokemonResponse&gt;(\"https://pokeapi.co/api/v2/pokemon\") {\n      contentType(ContentType.Application.Json)\n    }\nresponse.onSuccess {\n    ..\n}.onError {\n    ..\n}.onException {\n    ..\n}\n</code></pre>"},{"location":"ktor/#apiresponse-extensions-for-ktor","title":"ApiResponse Extensions for Ktor","text":"<p>The sandwich-ktor package provides valuable property extensions for <code>ApiResponse</code>.</p>"},{"location":"ktor/#apiresponsesuccess","title":"ApiResponse.Success","text":"<p>This indicates a successful network request. From the <code>ApiResponse.Success</code>, you can retrieve the response's body data as well as supplementary details such as <code>StatusCode</code>, <code>Headers</code>, and more.</p> <pre><code>val data: List&lt;Poster&gt; = response.data // or response.body()\nval statusCode: StatusCode = response.statusCode\nval headers: Headers = response.headers\nval httpResponse: HttpResponse = response.httpResponse\n</code></pre>"},{"location":"ktor/#apiresponsefailureerror","title":"ApiResponse.Failure.Error","text":"<p>This denotes a failed network request, typically due to bad requests or internal server errors. You can access error messages and additional information like <code>StatusCode</code>, <code>Headers</code>, and more from the <code>ApiResponse.Failure.Error</code>.</p> <pre><code>val bodyChannel: String = response.bodyChannel()\nval bodyString: String = response.bodyString()\nval statusCode: StatusCode = response.statusCode\nval headers: Headers = response.headers\n</code></pre>"},{"location":"ktorfit/","title":"Ktorfit Integration","text":"<p>Sandwich offers seamless extensions of <code>ApiResponse</code> for Ktorfit by utilizing Sandwich's converter factory. Basically, Ktorfit was built top of the Ktor, so you can use Ktor extensions as well.</p> <p>To utilize these Ktorfit supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:sandwich-ktorfit:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:sandwich-ktorfit:$version\")\n}\n</code></pre> <p>For Kotlin Multiplatform, add the dependency below to your module's <code>build.gradle.kts</code> file:</p> <pre><code>sourceSets {\n    val commonMain by getting {\n        dependencies {\n            implementation(\"com.github.skydoves:sandwich-ktorfit:$version\")\n        }\n    }\n}\n</code></pre>"},{"location":"ktorfit/#apiresponseconverterfactory","title":"ApiResponseConverterFactory","text":"<p>First, build your <code>Ktorfit</code> instance with the <code>ApiResponseConverterFactory</code> call adapter factory:</p> <pre><code>val ktorfit = Ktorfit.Builder()\n    .baseUrl(BASE_URL)\n    .converterFactories(ApiResponseConverterFactory.create())\n    .build()\n</code></pre> <p>Next, define your service interface with the <code>suspend</code> keyword and <code>ApiResponse&lt;*&gt;</code> as the response type:</p> <pre><code>interface MyApiService {\n\n  @GET(\"DisneyPosters.json\")\n  suspend fun fetchData(): ApiResponse&lt;List&lt;Poster&gt;&gt;\n}\n</code></pre> <p>Lastly, execute the defined service to receive the <code>ApiResponse</code>:</p> <pre><code>val apiService = ktorfit.createMyApiService()\nval response: ApiResponse&lt;List&lt;Poster&gt;&gt; = apiService.fetchData()\nresponse.onSuccess {\n    // handles the success case when the API request gets a successful response.\n    mutableStateFlow.value = data\n  }.onError {\n    // handles error cases when the API request gets an error response.\n  }.onException {\n    // handles exceptional cases when the API request gets an exception response.\n}\n</code></pre>"},{"location":"ktorfit/#apiresponse-from-the-httpclient","title":"ApiResponse from the HttpClient","text":"<p>Basically, Ktorfit is built on top of Ktor, so you can leverage all <code>ApiResponse</code> extensions as described in the Ktor documentation.</p>"},{"location":"mapper/","title":"Mapper","text":"<p>Sandwich provides versatile mapping extensions for <code>ApiResponse</code>.</p>"},{"location":"mapper/#mapsuccess-and-suspendmapsuccess","title":"mapSuccess and suspendMapSuccess","text":"<p>If the <code>ApiResponse</code> is of type <code>ApiResponse.Success</code>, this function maps a <code>T</code> type to a <code>V</code> type within the <code>ApiResponse</code>.</p> <p>The provided example below illustrates the utilization of the <code>mapSuccess</code> function to map the <code>ApiResponse&lt;UserAuthResponse&gt;</code> type to <code>ApiResponse&lt;LoginInfo&gt;</code>.</p> <pre><code>class LoginRepositoryImpl {\n    override fun requestToken(\n        authProvider: String,\n        authIdentifier: String,\n        email: String,\n    ): Flow&lt;ApiResponse&lt;LoginInfo&gt;&gt; = flow {\n        val result = authService.requestToken(\n            UserRequest(\n                authProvider = authProvider,\n                authIdentifier = authIdentifier,\n                email = email,\n            ),\n        ).mapSuccess { LoginInfo(user = user, token = token) }\n        emit(result)\n    }.flowOn(ioDispatcher)\n}\n</code></pre>"},{"location":"mapper/#mapfailure-and-suspendmapfailure","title":"mapFailure and suspendMapFailure","text":"<p>In case the <code>ApiResponse</code> is of type <code>ApiResponse.Failure</code>, this operation maps a <code>T</code> type from the <code>ApiResponse</code> to a <code>V</code> type.</p> <p>It's useful when you need to manipulate the error response deliberately.</p> <pre><code>val apiResponse2 = apiResponse1.mapFailure { responseBody -&gt;\n      \"error body: ${responseBody?.string()}\".toResponseBody()\n    }\n</code></pre>"},{"location":"mapper/#model-mapper","title":"Model Mapper","text":"<p>Mappers are especially useful when you need to transform the <code>ApiResponse.Success</code> or <code>ApiResponse.Failure.Error</code> into your custom model within the extension scopes of <code>ApiResponse</code>.</p>"},{"location":"mapper/#apisuccessmodelmapper","title":"ApiSuccessModelMapper","text":"<p>You can map the <code>ApiResponse.Success</code> model to your custom model using the <code>SuccessPosterMapper&lt;T, R&gt;</code> and the <code>map</code> extension as demonstrated below:</p> <pre><code>object SuccessPosterMapper : ApiSuccessModelMapper&lt;List&lt;Poster&gt;, Poster?&gt; {\n\n  override fun map(apiSuccessResponse: ApiResponse.Success&lt;List&lt;Poster&gt;&gt;): Poster? {\n    return apiSuccessResponse.data.first()\n  }\n}\n\n// Maps the success response data.\nval poster: Poster? = map(SuccessPosterMapper)\n</code></pre> <p>You can also use the <code>map</code> extension with a lambda expression as shown below:</p> <pre><code>// Maps the success response data using a lambda.\nmap(SuccessPosterMapper) { poster -&gt;\n  emit(poster) // You can use the `this` keyword instead of \"poster\".\n}\n</code></pre> <p>If you want to receive transformed body data within the scope, you can utilize the mapper as a parameter with the <code>onSuccess</code> or <code>suspendOnSuccess</code> extensions, as illustrated below:</p> <pre><code>apiResponse.suspendOnSuccess(SuccessPosterMapper) {\n    val poster = this\n}\n</code></pre>"},{"location":"mapper/#apierrormodelmapper","title":"ApiErrorModelMapper","text":"<p>You can utilize mappers to convert the <code>ApiResponse.Failure.Error</code> model to your custom error model using the <code>ApiErrorModelMapper&lt;T&gt;</code> and the <code>map</code> extension, as demonstrated in the examples below:</p> <pre><code>// Define your custom error model.\ndata class ErrorEnvelope(\n  val code: Int,\n  val message: String\n)\n\n// Create a mapper for error responses.\n// Within the `map` function, construct an instance of your custom model using the information from `ApiResponse.Failure.Error`.\nobject ErrorEnvelopeMapper : ApiErrorModelMapper&lt;ErrorEnvelope&gt; {\n\n  override fun map(apiErrorResponse: ApiResponse.Failure.Error&lt;*&gt;): ErrorEnvelope {\n    return ErrorEnvelope(apiErrorResponse.statusCode.code, apiErrorResponse.message())\n  }\n}\n\n// Apply the mapper to an error response.\nresponse.onError {\n  // Use the mapper to convert ApiResponse.Failure.Error to your custom error model.\n  map(ErrorEnvelopeMapper) {\n     val code = this.code\n     val message = this.message\n  }\n}\n</code></pre> <p>If you intend to obtain transformed data within the scope, you can use the mapper as a parameter with the <code>onError</code> or <code>suspendOnError</code> extensions, as shown in the examples below:</p> <pre><code>apiResponse.suspendOnError(ErrorEnvelopeMapper) {\n    val message = this.message\n}\n</code></pre>"},{"location":"mapper/#global-failure-mapper","title":"Global Failure Mapper","text":"<p>You can map <code>ApiResponse.Failure</code> responses into your custom error response by using <code>flatMap</code> as described ApiResponse.Failure.Error documentation.</p> <p>Alternatively, Sandwich provides a robust solution for mapping responses, enabling you to transform all <code>ApiResponse.Failure</code> responses into your preferred <code>ApiResponse.Failure.Error</code> or <code>ApiResponse.Failure.Exception</code> types. This can be applied globally without the need for using <code>flatMap</code> extensions across all network and I/O requests or when creating <code>ApiResponse</code> instances.</p> <p>You can implement this globally by using <code>SandwichInitializer.sandwichFailureMappers</code>. The example below shows how to map all your <code>ApiResponse.Failure.Error</code> to your custom <code>ApiResponse.Failure.Exception</code>.</p> <pre><code>data object UnKnownError : ApiResponse.Failure.Exception(\n  throwable = RuntimeException(\"unknwon error\")\n)\n\ndata object LimitedRequest : ApiResponse.Failure.Exception(\n  throwable = RuntimeException(\"your request is limited\")\n)\n\ndata object WrongArgument : ApiResponse.Failure.Exception(\n  throwable = RuntimeException(\"wrong argument\")\n)\n\ndata object HttpException : ApiResponse.Failure.Exception(\n  throwable = RuntimeException(\"http exception\"),\n)\n\nSandwichInitializer.sandwichFailureMappers += listOf(\n  object : ApiResponseFailureMapper {\n    override fun map(apiResponse: ApiResponse.Failure&lt;*&gt;): ApiResponse.Failure&lt;*&gt; {\n      if (apiResponse is ApiResponse.Failure.Error) {\n        val errorBody = (apiResponse.payload as? okhttp3.Response)?.body?.string()\n        if (errorBody != null) {\n          val errorMessage: ErrorMessage = Json.decodeFromString(errorBody)\n          when (errorMessage.code) {\n            10000 -&gt; LimitedRequest\n            10001 -&gt; WrongArgument\n            10002 -&gt; HttpException\n            else -&gt; UnKnownError\n          }\n        }\n      }\n      return apiResponse\n    }\n  },\n)\n</code></pre> <p>Given the example above, which maps all <code>ApiResponse.Failure.Error</code> to your custom <code>ApiResponse.Failure.Exception</code> according to your preferences, you'll only need to focus on handling exceptional cases when dealing with your <code>ApiResponse</code>.</p> <pre><code>val apiResponse = service.fetchMovieList()\napiResponse.onSuccess {\n  // ..\n}.onException {\n  when (this) {\n    LimitedRequest -&gt; // ..\n    WrongArgument -&gt; // ..\n    HttpException -&gt; // ..\n    UnKnownError -&gt; // ..\n  }\n}\n</code></pre>"},{"location":"mapper/#suspend-global-failure-mapper-ktorktorfit","title":"Suspend Global Failure Mapper (Ktor/Ktorfit)","text":"<p>If you're using Ktor or Ktorfit, parsing the error response body requires suspend functions (e.g., <code>bodyAsText()</code>). In this case, use <code>ApiResponseFailureSuspendMapper</code> instead of <code>ApiResponseFailureMapper</code>. The suspend mapper is properly awaited in suspend contexts, ensuring the mapped response is correctly returned to callers.</p> <pre><code>SandwichInitializer.sandwichFailureMappers += listOf(\n  object : ApiResponseFailureSuspendMapper {\n    override suspend fun map(apiResponse: ApiResponse.Failure&lt;*&gt;): ApiResponse.Failure&lt;*&gt; {\n      if (apiResponse is ApiResponse.Failure.Error) {\n        val errorBody = (apiResponse.payload as? HttpResponse)?.bodyAsText()\n        if (errorBody != null) {\n          val errorMessage: ErrorMessage = Json.decodeFromString(errorBody)\n          return when (errorMessage.code) {\n            10000 -&gt; LimitedRequest\n            10001 -&gt; WrongArgument\n            10002 -&gt; HttpException\n            else -&gt; UnKnownError\n          }\n        }\n      }\n      return apiResponse\n    }\n  },\n)\n</code></pre> <p>Note</p> <p><code>ApiResponseFailureSuspendMapper</code> is designed for suspend contexts (Ktor, Ktorfit, and <code>suspendOf</code>). If you're using Retrofit with synchronous response handling, use <code>ApiResponseFailureMapper</code> instead.</p>"},{"location":"merge/","title":"Merge","text":"<p>You can merge <code>ApiResponse</code>s that contain a <code>List</code> as their generic type into a single <code>ApiResponse</code> based on specific policies. The example below shows how to merge three <code>ApiResponse</code> as a single one if each three <code>ApiResponse</code>s are successful.</p>"},{"location":"merge/#merging-multiple-apiresponse","title":"Merging Multiple ApiResponse","text":"<p>Sandwich allows you to merge multiple <code>ApiResponse</code> instances into a single one based on predefined policies. This is particularly useful when you need to combine the results of multiple API calls. The following example demonstrates how to merge three <code>ApiResponse</code> instances into a single one, provided that all three <code>ApiResponse</code> instances are successful:</p> <pre><code>disneyService.fetchDisneyPosterList(page = 0).merge(\n   disneyService.fetchDisneyPosterList(page = 1),\n   disneyService.fetchDisneyPosterList(page = 2),\n   mergePolicy = ApiResponseMergePolicy.PREFERRED_FAILURE\n).onSuccess { \n  // handles the success case when the merged API requests all receive successful responses.\n}.onError { \n  // handles error cases when at least one of the merged API requests gets an error response.\n}\n</code></pre>"},{"location":"merge/#apiresponsemergepolicy","title":"ApiResponseMergePolicy","text":"<p><code>ApiResponseMergePolicy</code> is an enum that defines how merging should be performed based on the success or failure of the responses. There are two policies available:</p> <ul> <li>IGNORE_FAILURE: This policy ignores failure responses and considers only the successful ones when merging the <code>ApiResponse</code> instances, regardless of the order in which they are merged.</li> <li>PREFERRED_FAILURE (default): This policy prefers failure responses over success responses when merging. Even if there is one failure response in the merged list, the final merged <code>ApiResponse</code> will be marked as a failure.</li> </ul> <p>By choosing an appropriate merge policy, you can tailor the merging behavior to your specific requirements, ensuring that the merged <code>ApiResponse</code> accurately represents the combined results of the individual API calls.</p>"},{"location":"migration/","title":"Migration Guide","text":"<p>This is a migration guide from 1.x to 2.0.0.</p>"},{"location":"migration/#1-dependencies","title":"1. Dependencies","text":"<p>First, you should use add additional libraries to fully migrate from 1.x version.</p> <pre><code>implementation(\"com.github.skydoves:sandwich:$version\")\nimplementation(\"com.github.skydoves:sandwich-retrofit:$version\")\nimplementation(\"com.github.skydoves:sandwich-retrofit-serialization:$version\")\n</code></pre>"},{"location":"migration/#2-adapterfactory-and-interceptor","title":"2. AdapterFactory and Interceptor","text":"<p>If you were using <code>ApiResponseCallAdapterFactory</code> and <code>EmptyBodyInterceptor</code>, the package name should be change like so:</p> <pre><code>- import com.skydoves.sandwich.adapters.ApiResponseCallAdapterFactory\n+ import com.skydoves.sandwich.retrofit.adapters.ApiResponseCallAdapterFactory\n\n- import com.skydoves.sandwich.interceptors.EmptyBodyInterceptor\n+ import com.skydoves.sandwich.retrofit.interceptors.EmptyBodyInterceptor\n</code></pre>"},{"location":"migration/#3-operator","title":"3. Operator","text":"<p>If you're using Operator, the override function should be change like the code below:</p> <pre><code>class TestApiResponseSuspendOperator&lt;T&gt;(\n  private val onSuccess: suspend () -&gt; Unit,\n  private val onError: suspend () -&gt; Unit,\n  private val onException: suspend () -&gt; Unit,\n) : ApiResponseSuspendOperator&lt;T&gt;() {\n\n  override suspend fun onSuccess(apiResponse: ApiResponse.Success&lt;T&gt;) = onSuccess()\n\n-  override suspend fun onError(apiResponse: ApiResponse.Failure.Error&lt;T&gt;) = onError()\n+  override suspend fun onError(apiResponse: ApiResponse.Failure.Error) = onError()\n\n-  override suspend fun onException(apiResponse: ApiResponse.Failure.Exception&lt;T&gt;) = onException()\n+  override suspend fun onException(apiResponse: ApiResponse.Failure.Exception) = onException()\n}\n</code></pre>"},{"location":"migration/#4-apiresponseerrorthrowable","title":"4. ApiResponse.error(throwable)","text":"<p>The previous <code>ApiResponse.error(throwable)</code> function was renamed to <code>ApiResponse.exception(throwable)</code>.</p> <pre><code>- val apiResponse = ApiResponse.error(throwable)\n+ val apiResponse = ApiResponse.exception(throwable)\n</code></pre>"},{"location":"operator/","title":"Operator","text":"<p>The Operator feature stands out as one of the most powerful capabilities provided by Sandwich. It empowers you to establish well-defined, preconfigured processors for your <code>ApiResponse</code> instances. This enables you to encapsulate and reuse a consistent sequence of procedures across your API requests.</p> <p>You can streamline the handling of <code>onSuccess</code>, <code>onError</code>, and <code>onException</code> scenarios by utilizing the <code>operator</code> extension alongside the <code>ApiResponseOperator</code>. Operator proves particularly valuable when you're aiming for global handling of <code>ApiResponse</code> instances and wish to minimize boilerplate code within your <code>ViewModel</code> and <code>Repository</code> classes. Here are a few illustrative examples:</p> <pre><code>/** A common response operator for handling [ApiResponse]s regardless of its type. */\nclass CommonResponseOperator&lt;T&gt;(\n  private val success: suspend (ApiResponse.Success&lt;T&gt;) -&gt; Unit\n) : ApiResponseOperator&lt;T&gt;() {\n\n  // handles error cases when the API request gets an error response.\n  override fun onSuccess(apiResponse: ApiResponse.Success&lt;T&gt;) = success(apiResponse)\n\n  // handles error cases depending on the status code.\n  // e.g., internal server error.\n  override fun onError(apiResponse: ApiResponse.Failure.Error) {\n    apiResponse.run {\n      Timber.d(message())\n\n      // map the ApiResponse.Failure.Error to a customized error model using the mapper.\n      map(ErrorEnvelopeMapper) {\n        Timber.d(\"[Code: $code]: $message\")\n      }\n    }\n  }\n\n  // handles exceptional cases when the API request gets an exception response.\n  // e.g., network connection error, timeout.\n  override fun onException(apiResponse: ApiResponse.Failure.Exception) {\n    apiResponse.run {\n      Timber.d(message())\n    }\n  }\n}\n\ndisneyService.fetchDisneyPosterList().operator(\n    CommonResponseOperator(\n      success = {\n        emit(data)\n        Timber.d(\"success data: $data\")\n     }\n    )\n)\n</code></pre> <p>By embracing the Operator pattern, you can significantly simplify the management of various <code>ApiResponse</code> outcomes and promote cleaner, more maintainable code within your application's architecture.</p>"},{"location":"operator/#operator-with-coroutines","title":"Operator With Coroutines","text":"<p>For scenarios where you aim to delegate and operate a suspension lambda using the operator pattern, the <code>suspendOperator</code> extension and the <code>ApiResponseSuspendOperator</code> class come into play. These tools facilitate the process, as showcased in the examples below:</p> <pre><code>class CommonResponseOperator&lt;T&gt;(\n  private val success: suspend (ApiResponse.Success&lt;T&gt;) -&gt; Unit\n) : ApiResponseSuspendOperator&lt;T&gt;() {\n\n  // handles the success case when the API request gets a successful response.\n  override suspend fun onSuccess(apiResponse: ApiResponse.Success&lt;T&gt;) = success(apiResponse)\n\n  // ... //\n}\n</code></pre> <p>You can use suspend functions like <code>emit</code> in the <code>success</code> scope.</p> <pre><code>val response = disneyService.fetchDisneyPosterList().suspendOperator(\n    CommonResponseOperator(\n      success = {\n        emit(data)\n        Timber.d(\"success data: $data\")\n      }\n    )\n)\n</code></pre> <p>Incorporating the suspendOperator extension alongside the ApiResponseSuspendOperator class allows you to efficiently manage suspension lambdas in conjunction with the operator pattern, promoting a more concise and maintainable approach within your codebase.</p>"},{"location":"operator/#global-operator","title":"Global Operator","text":"<p>The global operator is undoubtedly a robust feature offered by Sandwich. It empowers you to operate on operators globally across all <code>ApiResponse</code> instances in your application by employing the <code>SandwichInitializer</code>. This way, you can avoid the necessity of creating operator instances for every API call or employing dependency injection for common operations. The following examples illustrate how to use a global operator to handle both <code>ApiResponse.Failure.Error</code> and <code>ApiResponse.Failure.Exception</code> scenarios. You can leverage the global operator to refresh your user token or implement any other additional processes necessary for specific API requests within your application. The example below demonstrates how you can automatically check and refresh the user token depending on the response status using Sandwich's global operator:</p>"},{"location":"operator/#initialize-global-operator","title":"Initialize Global Operator","text":"<p>First, it's highly recommended to initialize the global operator in the Application class or using another initialization solution like App Startup. This ensures that the global operator is set up before any API requests are made.</p> <pre><code>class SandwichDemoApp : Application() {\n\n  override fun onCreate() {\n    super.onCreate()\n\n    // We will handle only the error and exceptional cases,\n    // so we don't need to mind the generic type of the operator.\n    SandwichInitializer.sandwichOperators += listOf(TokenRefreshGlobalOperator&lt;Any&gt;(this))\n\n    // ... //\n  }\n}\n</code></pre> <p>By configuring the global operator within <code>SandwichInitializer</code>, you enable your application to consistently process and handle various <code>ApiResponse</code> situations. This can include tasks such as managing success cases, handling errors, or dealing with exceptions, all on a global scale.</p>"},{"location":"operator/#implement-your-global-operator","title":"Implement Your Global Operator","text":"<p>Create your custom <code>GlobalResponseOperator</code> class that extends operators such as <code>ApiResponseSuspendOperator</code> and <code>ApiResponseOperator</code>. This operator will allow you to define common response handling logic that can be applied globally.</p> <pre><code>class TokenRefreshGlobalOperator&lt;T&gt; @Inject constructor(\n  private val context: Context,\n  private val authService: AuthService,\n  private val userDataStore: UserDataStore,\n  coroutineScope: CoroutineScope,\n) : ApiResponseSuspendOperator&lt;T&gt;() {\n\n  private var userToken: UserToken? = null\n\n  init {\n    coroutineScope.launch {\n      userDataStore.tokenFlow.collect { token -&gt;\n        userToken = token\n      }\n    }\n  }\n\n  override suspend fun onError(apiResponse: ApiResponse.Failure.Error) {\n    // verify whether the current request was previously issued as an authenticated request\n    apiResponse.headers[\"Authorization\"] ?: return\n\n    // refresh an access token if the error response is Unauthorized or Forbidden\n    when (apiResponse.statusCode) {\n      StatusCode.Unauthorized, StatusCode.Forbidden -&gt; {\n        userToken?.let { token -&gt;\n          val result = authService.refreshToken(token)\n          result.onSuccessSuspend { data -&gt;\n            userDataStore.updateToken(\n              UserToken(\n                accessToken = data.accessToken,\n                refreshToken = data.refreshToken,\n              ),\n            )\n            toast(R.string.toast_refresh_token_succeed)\n          }.onFailureSuspend {\n            toast(R.string.toast_refresh_token_failed)\n          }\n        }\n      }\n      else -&gt; Unit\n    }\n  }\n\n  override suspend fun onSuccess(apiResponse: ApiResponse.Success&lt;T&gt;) = Unit\n\n  override suspend fun onException(apiResponse: ApiResponse.Failure.Exception) = Unit\n\n  private suspend fun toast(@StringRes resource: Int) = withContext(Dispatchers.Main) {\n    Toast.makeText(context, resource, Toast.LENGTH_SHORT).show()\n  }\n}\n</code></pre> <p>In this example, the global operator's <code>onError</code> function is used to automatically check for <code>Unauthorized</code> and <code>Forbidden</code> status code (HTTP 401 and 403) in the error response. If an unauthorized error occurs, the user token is refreshed, and the failed request is retried with the updated token using runAndRetry. This way, you can seamlessly manage token expiration and refresh for your API requests.</p>"},{"location":"operator/#global-operator-with-hilt-and-app-startup","title":"Global Operator With Hilt and App Startup","text":"<p>If you want to initialize the global operator by using with Hilt and App Startup, you can follow the instructions below.</p>"},{"location":"operator/#1-implement-an-entry-point","title":"1. Implement an Entry Point","text":"<p>First, you should implement an entry point for injecting the global operator into an App Startup initializer.</p> <pre><code>@EntryPoint\n@InstallIn(SingletonComponent::class)\ninterface NetworkEntryPoint {\n\n  fun inject(networkInitializer: NetworkInitializer)\n\n  companion object {\n\n    fun resolve(context: Context): NetworkEntryPoint {\n      val appContext = context.applicationContext ?: throw IllegalStateException(\n        \"applicationContext was not found in NetworkEntryPoint\",\n      )\n      return EntryPointAccessors.fromApplication(\n        appContext,\n        NetworkEntryPoint::class.java,\n      )\n    }\n  }\n}\n</code></pre>"},{"location":"operator/#2-provide-global-operator-dependency","title":"2. Provide Global Operator Dependency","text":"<p>Next, provide your global operator with Hilt like the example below:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n  @Provides\n  @Singleton\n  fun provideTokenRefreshGlobalOperator(\n    @ApplicationContext context: Context,\n    authService: AuthService,\n    userDataStore: UserDataStore\n  ): TokenRefreshGlobalOperator&lt;Any&gt; {\n    return TokenRefreshGlobalOperator(\n      context = context,\n      authService = authService,\n      userDataStore = userDataStore,\n      coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.IO),\n    )\n  }\n}\n</code></pre>"},{"location":"operator/#3-implement-app-startup-initializer","title":"3. Implement App Startup Initializer","text":"<p>Finally, implement the App Startup Initializer and initialize the Initializer following the App Startup guidance.</p> <pre><code>public class NetworkInitializer : Initializer&lt;Unit&gt; {\n\n  @set:Inject\n  internal lateinit var tokenRefreshGlobalOperator: TokenRefreshGlobalOperator&lt;Any&gt;\n\n  override fun create(context: Context) {\n    NetworkEntryPoint.resolve(context).inject(this)\n\n    SandwichInitializer.sandwichOperators += listOf(tokenRefreshGlobalOperator)\n  }\n\n  override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; = emptyList()\n}\n</code></pre>"},{"location":"retrieve/","title":"Retrieving","text":"<p>Sandwich provides effortless methods to directly extract the encapsulated body data from the <code>ApiResponse</code>. You can take advantage of the following functionalities:</p>"},{"location":"retrieve/#getornull","title":"getOrNull","text":"<p>Returns the encapsulated data if this instance represents <code>ApiResponse.Success</code> or returns null if this is failed.</p> <pre><code>val data: List&lt;Poster&gt;? = disneyService.fetchDisneyPosterList().getOrNull()\n</code></pre>"},{"location":"retrieve/#getorelse","title":"getOrElse","text":"<p>Returns the encapsulated data if this instance represents <code>ApiResponse.Success</code> or returns a default value if this is failed.</p> <pre><code>val data: List&lt;Poster&gt; = disneyService.fetchDisneyPosterList().getOrElse(emptyList())\n</code></pre>"},{"location":"retrieve/#getorthrow","title":"getOrThrow","text":"<p>Returns the encapsulated data if this instance represents <code>ApiResponse.Success</code> or throws the encapsulated <code>Throwable</code> exception if this is failed.</p> <pre><code>try {\n  val data: List&lt;Poster&gt; = disneyService.fetchDisneyPosterList().getOrThrow()\n} catch (e: Exception) {\n  e.printStackTrace()\n}\n</code></pre>"},{"location":"retrofit/","title":"Retrofit Integration","text":"<p>Sandwich provides seamless ways to integrate the <code>ApiResponse&lt;*&gt;</code> type into your Retrofit services with Coroutines.</p> <p>To utilize these Retrofit supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:sandwich-retrofit:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:sandwich-retrofit:$version\")\n}\n</code></pre>"},{"location":"retrofit/#apiresponsecalladapterfactory","title":"ApiResponseCallAdapterFactory","text":"<p>First, build your <code>Retrofit</code> instance with the <code>ApiResponseCallAdapterFactory</code> call adapter factory:</p> <pre><code>val retrofit = Retrofit.Builder()\n    .baseUrl(BASE_URL)\n    .addCallAdapterFactory(ApiResponseCallAdapterFactory.create())\n    .build()\n</code></pre> <p>Next, define your service interface with the <code>suspend</code> keyword and <code>ApiResponse&lt;*&gt;</code> as the response type:</p> <pre><code>interface MyApiService {\n\n  @GET(\"DisneyPosters.json\")\n  suspend fun fetchData(): ApiResponse&lt;List&lt;Poster&gt;&gt;\n}\n</code></pre> <p>Lastly, execute the defined service to receive the <code>ApiResponse</code>:</p> <pre><code>val apiService = retrofit.create(MyApiService::class.java)\nval response: ApiResponse&lt;List&lt;Poster&gt;&gt; = apiService.fetchData()\nresponse.onSuccess {\n    // handles the success case when the API request gets a successful response.\n    mutableStateFlow.value = data\n  }.onError {\n    // handles error cases when the API request gets an error response.\n  }.onException {\n    // handles exceptional cases when the API request gets an exception response.\n}\n</code></pre> <p>By following these steps, you can easily utilize the <code>ApiResponse</code> type in your Retrofit services. If you're interested in injecting your own coroutine scope or performing unit tests with a test coroutine scope, you can refer to the Injecting a custom CoroutineScope and Unit Tests section for more details.</p> <p>Note: If you're interested in injecting your own coroutine scope and unit testing with a test coroutine scope, check out the Injecting a custom CoroutineScope and Unit Tests.</p>"},{"location":"retrofit/#apiresponse-extensions-for-retrofit","title":"ApiResponse Extensions for Retrofit","text":"<p>The sandwich-retrofit package provides valuable property extensions for <code>ApiResponse</code>.</p>"},{"location":"retrofit/#apiresponsesuccess","title":"ApiResponse.Success","text":"<p>This indicates a successful network request. From the <code>ApiResponse.Success</code>, you can retrieve the response's body data as well as supplementary details such as <code>StatusCode</code>, <code>Headers</code>, and more.</p> <pre><code>val data: List&lt;Poster&gt; = response.data // or response.body \nval statusCode: StatusCode = response.statusCode\nval headers: Headers = response.headers\nval raw: okhttp3.Response = response.raw\n</code></pre>"},{"location":"retrofit/#apiresponsefailureerror","title":"ApiResponse.Failure.Error","text":"<p>This denotes a failed network request, typically due to bad requests or internal server errors. You can access error messages and additional information like <code>StatusCode</code>, <code>Headers</code>, and more from the <code>ApiResponse.Failure.Error</code>.</p> <pre><code>val message: String = response.message()\nval errorBody: ResponseBody? = response.errorBody\nval statusCode: StatusCode = response.statusCode\nval headers: Headers = response.headers\nval raw: okhttp3.Response = response.raw\n</code></pre>"},{"location":"retrofit/#injecting-a-custom-coroutinescope-and-unit-tests","title":"Injecting a Custom CoroutineScope and Unit Tests","text":"<p>You can inject your own custom <code>CoroutineScope</code> into Sandwich's internal execution by setting it on the <code>ApiResponseCallAdapterFactory</code>:</p> <pre><code>.addCallAdapterFactory(ApiResponseCallAdapterFactory.create(\n  coroutineScope = `Your Coroutine Scope`\n))\n</code></pre> <p>To apply your custom coroutine scope globally for the <code>ApiResponseCallAdapterFactory</code>, set your scope on <code>SandwichInitializer</code>:</p> <pre><code>SandwichInitializer.sandwichScope = `Your Coroutine Scope`\n</code></pre> <p>Additionally, you can inject a test coroutine scope into the <code>ApiResponseCallAdapterFactory</code> for your unit test cases:</p> <pre><code>val testScope = TestScope(coroutinesRule.testDispatcher)\nval retrofit = Retrofit.Builder()\n      .baseUrl(mockWebServer.url(\"/\"))\n      .addConverterFactory(MoshiConverterFactory.create())\n      .addCallAdapterFactory(ApiResponseCallAdapterFactory.create(testScope))\n      .build()\n</code></pre> <p>By following these guidelines, you can effectively manage coroutine scopes within Sandwich, making it suitable for a variety of use cases and ensuring robustness in unit testing scenarios.</p>"},{"location":"retrofit/#serialization-for-retrofit","title":"Serialization for Retrofit","text":"<p>Sandwich facilitates the deserialization of your Retrofit response's error body into your customized error class, utilizing Kotlin's Serialization.</p> <p>Note</p> <p>To learn more about configuring the plugin and its dependency, refer to Kotlin's Serialization documentation.</p> <p></p> <p>Add the dependency below to your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:sandwich-retrofit-serialization:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:sandwich-retrofit-serialization:$version\")\n}\n</code></pre>"},{"location":"retrofit/#error-body-deserialization","title":"Error Body Deserialization","text":"<p>To deserialize your error body, utilize the <code>deserializeErrorBody</code> extension along with your custom error class. Begin by defining your custom error class adhering to the formats of your RESTful API, as shown below:</p> <pre><code>@Serializable\ndata class ErrorMessage(\n    val code: Int,\n    val message: String\n)\n</code></pre> <p>Subsequently, retrieve the error class result from the <code>ApiResponse</code> instance using the <code>deserializeErrorBody</code> extension, as demonstrated in the example below:</p> <pre><code>val apiResponse = pokemonService.fetchPokemonList()\nval errorModel: ErrorMessage? = apiResponse.deserializeErrorBody&lt;String, ErrorMessage&gt;()\n</code></pre> <p>Alternatively, you can directly obtain the deserialized error response through the <code>onErrorDeserialize</code> extension, as depicted here:</p> <pre><code>val apiResponse = mainRepository.fetchPosters()\napiResponse.onErrorDeserialize&lt;List&lt;Poster&gt;, ErrorMessage&gt; { errorMessage -&gt;\n  // Handle the error message\n}\n</code></pre>"},{"location":"retrofit/#creating-apiresponse-from-retrofit-response","title":"Creating ApiResponse from Retrofit Response","text":"<p>If you need to create an <code>ApiResponse</code> from the Retrofit's <code>Response&lt;T&gt;</code> class, you can utilize <code>apiResponseOf</code> or <code>suspendApiResponseOf</code> extensions below:</p> <pre><code>val response: retrofit2.Response&lt;Pokemon&gt; = service.fetchPokemon()\nval apiResponse = apiResponseOf { response }\n</code></pre>"},{"location":"retry/","title":"Retry","text":"<p>Sandwich offers seamless ways to run and retry tasks. To execute and retry network or I/O requests, you can employ the <code>RetryPolicy</code> interface along with the <code>runAndRetry</code> extension, as demonstrated in the code below:</p> <pre><code>val retryPolicy = object : RetryPolicy {\n  override fun shouldRetry(attempt: Int, message: String?): Boolean = attempt &lt;= 3\n\n  override fun retryTimeout(attempt: Int, message: String?): Int = 3000\n}\n\nval apiResponse = runAndRetry(retryPolicy) { attempt, reason -&gt;\n  mainRepository.fetchPosters()\n}.onSuccess {\n  // Handle a success case\n}.onFailure {\n  // Handle failure cases\n}\n</code></pre> <p>This setup allows you to define a retry policy that determines whether a retry attempt should occur and specifies the retry timeout. The <code>runAndRetry</code> extension then encapsulates the execution logic, applying the defined policy, and providing the response in a clean and structured manner.</p>"},{"location":"sequential/","title":"Sequential","text":"<p>Sandwich provides sequential solutions for scenarios where you require sequential execution of network requests.</p>"},{"location":"sequential/#then-and-suspendthen","title":"then and suspendThen","text":"<p>If you have a scenario where you need to execute tasks A, B, and C in a dependent sequence, for example, where task B depends on the completion of task A, and task C depends on the completion of task B, you can effectively utilize the <code>then</code> or <code>suspendThen</code> extensions, as demonstrated in the example below:</p> <pre><code>service.getUserToken(id) suspendThen { tokenResponse -&gt;\n    service.getUserDetails(tokenResponse.token) \n} suspendThen { userResponse -&gt;\n    service.queryPosters(userResponse.user.name)\n}.mapSuccess { posterResponse -&gt;\n  posterResponse.posters\n}.onSuccess {\n    posterStateFlow.value = data\n}.onFailure {\n    Log.e(\"sequential\", message())\n}\n</code></pre>"},{"location":"sponsor/","title":"Sponsor \ud83e\ude77","text":"<p>Jaewoong has created and contributed more than +75 open-source projects and libraries related to Android and Kotlin. With over his open-source projects and libraries, his work has left a significant impact on the development landscape. These projects have been widely embraced by millions of projects, software engineers, and end-users worldwide, with prominent organizations like PayPal, Twitter, Wikipedia, and others benefiting from their creations.</p> <p>If your team or personal projects have benefited from reduced development costs by using this library, you can show your appreciation and support by sponsoring him through the links below:</p> <ul> <li>GitHub Sponsor</li> <li>PayPal</li> </ul> <p>Sponsoring helps sustain the continuous development and improvement of the library, ensuring that it remains a valuable resource for the community. Your contribution not only shows gratitude but also contributes to the growth and success of open-source projects like this one. Feel free to lend your support and make a positive impact on the developer's efforts.</p> <p>If you want to suggest a feature request or sponsorship collaboration, you can reach out to the author with the contacts below:</p> <ul> <li>skydoves2@gmail.com</li> <li>Twitter</li> </ul>"},{"location":"sponsor/#sponsors","title":"Sponsors","text":"<p>Be the first sponsor for this library!</p> <p></p>"}]}